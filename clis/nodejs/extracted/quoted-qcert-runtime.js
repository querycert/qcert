const runtime = "\n/*\n * Copyright 2015-2016 IBM Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* \"standard library\" (implementation of unary and binary operators) */\n/* XXX TODO\n   -- never use 'in' always use 'hasObjectProperty()' instead\n   -- never use '==' or '!=' always use '===' or '!==' instead\n   -- never use 'i++' always use 'i = i+1'\n*/\nfunction unwrap(doc) {\n    // Unwrap for Enhanced TxStore format\n    if (\"state\" in doc && !(\"$class\" in doc)) {\n if (doc.state == \"COMMITTED\")\n     return JSON.parse(doc.currentValue);\n else\n     return null; // Not sure if we will need something more fancy for un-committed data\n    }\n    // Leave as-is\n    else\n return doc;\n}\nfunction concat(r1, r2) {\n    var result = { };\n    for (var key2 in r2)\n        result[key2] = r2[key2];\n    for (var key1 in r1)\n        if (!(key1 in r2))\n            result[key1] = r1[key1];\n    return result;\n}\nfunction contains(v, b) {\n    for (var i=0; i<b.length; i++)\n if (equal(v, toLeft(b[i])))\n     return true;\n    return false;\n}\nfunction distinct(b) {\n    var result = [ ];\n    for (var i=0; i<b.length; i++) {\n        var v = b[i];\n        var dup = false;\n        for (var j=0; j<result.length;j++) {\n            if (equal(v,result[j])) { dup = true; break; }\n        }\n        if (!(dup)) { result.push(v); } else { dup = false; }\n    }\n    return result;\n}\nfunction fastdistinct(b) {\n    b1 = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */\n    b1.sort(compare);\n    var result = [ ];\n    var v1 = null;\n    var v2 = null;\n    for (var i=0; i<b1.length; i++) {\n        var v1 = b1[i];\n if (i == (b1.length -1)) {\n     result.push(v1);\n }\n else {\n     v2 = b1[i+1];\n     if (equal(v1,v2)) {\n     } else {\n  result.push(v1);\n     }\n     v1 = v2;\n }\n    }\n    return result;\n}\nfunction compare(v1, v2) {\n    var t1 = typeof v1, t2 = typeof v2;\n    if (t1 == \"object\" && v1 !== null) {\n        if (v1.hasOwnProperty('$nat')) { t1 = \"number\"; v1 = v1.$nat; }\n    };\n    if (t2 == \"object\" && v2 !== null) {\n        if (v2.hasOwnProperty('$nat')) { t2 = \"number\"; v2 = v2.$nat; }\n    };\n    if (t1 != t2)\n        return t1 < t2 ? -1 : +1;\n    var a1 = {}.toString.apply(v1), a2 = {}.toString.apply(v2);\n    if (a1 != a2)\n        return a1 < a2 ? -1 : +1;\n    if (a1 == \"[object Array]\") {\n v1 = v1.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */\n v2 = v2.slice(); /* So we do the sort/compare on a clone of the original array */\n        v1.sort(compare);\n        v2.sort(compare);\n    }\n    if (t1 == \"object\") {\n var fields1 = [];\n var fields2 = [];\n for (var f1 in v1) { fields1.push(f1); }\n for (var f2 in v2) { fields2.push(f2); }\n fields1 = fields1.sort(compare);\n fields2 = fields2.sort(compare);\n        for (var i = 0; i < fields1.length; i++) {\n            if (!(fields1[i] in v2))\n                return -1;\n            var fc = compare(v1[fields1[i]], v2[fields1[i]]);\n            if (fc != 0)\n                return fc;\n        }\n for (var i = 0; i < fields2.length; i++) {\n            if (!(fields2[i] in v1))\n                return +1;\n }\n        return 0;\n    }\n    if (v1 != v2)\n        return v1 < v2 ? -1 : +1;\n    return 0;\n}\nfunction equal(v1, v2) {\n    return compare(v1, v2) == 0;\n}\nfunction compareOfMultipleCriterias(scl) {\n    return function(a,b) {\n var current_compare = 0;\n for (var i=0; i<scl.length; i++) {\n     var sc = scl[i];\n     if (\"asc\" in sc) { current_compare = compare(deref(a,sc['asc']), deref(b,sc['asc'])); }\n     else if (\"desc\" in sc) { current_compare = -(compare(deref(a,sc['asc']), deref(b,sc['asc']))); }\n\n     if (current_compare == -1) { return -1; }\n     else if(current_compare == 1) { return 1; }\n }\n return current_compare;\n    }\n    \n}\nfunction sort(b,scl) {\n    var result = [ ];\n    if (scl.length == 0) { return b; } // Check for no sorting criteria\n    var compareFun = compareOfMultipleCriterias(scl);\n    result = b.slice(); /* Sorting in place leads to inconsistencies, notably as it re-orders the input WM in the middle of processing */\n    result.sort(compareFun);\n    return result;\n}\nfunction flatten(aOuter) {\n    var result = [ ];\n    for (var iOuter=0, nOuter=aOuter.length; iOuter<nOuter; iOuter++) {\n var aInner = aOuter[iOuter];\n for (var iInner=0, nInner=aInner.length; iInner<nInner; iInner++)\n     result.push(aInner[iInner]);\n    }\n    return result;\n}\nfunction mergeConcat(r1, r2) {\n    var result = { };\n    for (var key1 in r1)\n result[key1] = r1[key1];\n    for (var key2 in r2) {\n if (key2 in r1) {\n            if (!equal(r1[key2], r2[key2])) {\n  return [ ];\n            }\n } else {\n     result[key2] = r2[key2];\n }\n    }\n    return [ result ];\n}\nfunction project(r1, p2) {\n    var result = { };\n    for (var key1 in r1) {\n if (!(p2.indexOf(key1) == -1))\n            result[key1] = r1[key1];\n    }\n    return result;\n}\nfunction remove(r, f) {\n    var result = { };\n    for (var key in r)\n if (key != f)\n     result[key] = r[key];\n    return result;\n}\nfunction sum(b) {\n    var result = 0;\n    for (var i=0; i<b.length; i++)\n result += b[i];\n    return result;\n}\nfunction arithMean(b) {\n    var len = b.length;\n    if(len == 0) {\n return 0;\n    } else {\n return sum(b)/len;\n    }\n}\nfunction toString(v) {\n    return toStringQ(v, \"\");\n}\nfunction generateText(v) {\n    return toStringQ(v, \"\");\n}\nfunction toStringQ(v, quote) {\n    if (v === null)\n return \"null\";\n    var t = typeof v;\n    if (t == \"string\")\n return quote + v + quote;\n    if (t == \"boolean\")\n return \"\" + v;\n    if (t == \"number\") {\n if (Math.floor(v) == v) return (new Number(v)).toFixed(1); // Make sure there is always decimal point\n else return \"\" + v;\n    }\n    if ({}.toString.apply(v) == \"[object Array]\") {\n v = v.slice();\n v.sort();\n var result = \"[\";\n for (var i=0, n=v.length; i<n; i++) {\n     if (i > 0)\n  result += \", \";\n     result += toStringQ(v[i], quote);\n }\n return result + \"]\";\n    }\n    if(v.hasOwnProperty('$nat')){\n return \"\" + v.$nat;\n    }\n    var result2 = \"\";\n    if (v.$type) { // branded value\n        result2 += \"<\";\n        result2 += v.$type;\n        result2 += \":\";\n        result2 += toStringQ(v.$data, quote);\n        result2 += \">\";\n    } else { // record\n        // First need to sort\n        var sortable = [];\n        for (var key in v) {\n            sortable.push({ key: key, val: v[key] });\n        }\n        sortable.sort(function(a, b) { return a.key.localeCompare(b.key); });\n        var result2 = \"{\";\n        var first = true;\n        for (var i=0, n=sortable.length; i<n; i++) {\n           if (first) first = false; else result2 += \", \";\n           result2 += toStringQ(sortable[i].key, quote) + \"->\" + toStringQ(sortable[i].val, quote);\n        }\n        result2 += \"}\";\n    }\n    return result2 + \"\";\n}\nfunction bunion(b1, b2) {\n    var result = [ ];\n    for (var i1=0; i1<b1.length; i1++)\n result.push(b1[i1]);\n    for (var i2=0; i2<b2.length; i2++)\n result.push(b2[i2]);\n    return result;\n}\nfunction bminus(b1, b2) {\n    var result = [ ];\n    var v1 = b1.slice();\n    var v2 = b2.slice();\n    v1.sort(compare);\n    v2.sort(compare);\n    var i2=0;\n    var length2=v2.length;\n    var comp=0;\n    for (var i1=0; i1<v1.length; i1++) {\n while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;\n if (i2 < length2) {\n     if(compare(v1[i1],v2[i2]) == (-1)) { result.push(v1[i1]); } else { i2++; }\n } else {\n     result.push(v1[i1]);\n }\n    }\n    return result;\n}\nfunction bmin(b1, b2) {\n    var result = [ ];\n    var v1 = b1.slice();\n    var v2 = b2.slice();\n    v1.sort(compare);\n    v2.sort(compare);\n    var i2=0;\n    var length2=v2.length;\n    var comp=0;\n    for (var i1=0; i1<v1.length; i1++) {\n while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) i2++;\n if (i2 < length2) {\n     if(compare(v1[i1],v2[i2]) == 0) result.push(v1[i1]);\n }\n    }\n    return result;\n}\nfunction bmax(b1, b2) {\n    var result = [ ];\n    var v1 = b1.slice();\n    var v2 = b2.slice();\n    v1.sort(compare);\n    v2.sort(compare);\n    var i2=0;\n    var length2=v2.length;\n    var comp=0;\n    for (var i1=0; i1<v1.length; i1++) {\n while ((i2 < length2) && (compare(v1[i1],v2[i2]) == 1)) { result.push(v2[i2]); i2++; }\n if (i2 < length2) {\n     if(compare(v1[i1],v2[i2]) == 0) i2++;\n }\n result.push(v1[i1]);\n    }\n    while (i2 < length2) { result.push(v2[i2]); i2++; }\n    return result;\n}\nfunction bnth(b1, n) {\n    var index = n;\n    if(n.hasOwnProperty('$nat')){\n     index = n.$nat;\n    }\n    if (b1[index]) {\n        return left(b1[index]);\n    } else {\n        return right(null);\n    }\n}\nfunction sub_brand(b1,b2) {\n    var bsub=null;\n    var bsup=null;\n    for (var i=0; i<inheritance.length; i++) {\n bsub = inheritance[i].sub;\n bsup = inheritance[i].sup;\n if ((b1 == bsub) && (b2 == bsup)) return true;\n    }\n    return false;\n}\nfunction left(v) {\n    return { \"$left\" : v };\n}\nfunction right(v) {\n    return { \"$right\" : v };\n}\nfunction mustBeArray(obj) {\n    if (Array.isArray(obj))\n return;\n    var e = new Error(\"Expected an array but got: \" + JSON.stringify(obj));\n    throw e;\n}\nfunction cast(brands,v) {\n    mustBeArray(brands);\n    if (\"$class\" in v)\n return enhanced_cast(brands,v);\n    var type = v.$type;\n    mustBeArray(type);\n    if (brands.length == 1 && brands[0] == \"Any\") { /* cast to top of inheritance is built-in */\n     return left(v);\n    }\n    brands:\n    for (var i in brands) {\n var b = brands[i];\n     for (var j in type) {\n         var t = type[j];\n         if (equal(t,b) || sub_brand(t,b))\n      continue brands;\n     }\n     /* the brand b does not appear in the type, so the cast fails */\n     return right(null);\n    }\n    /* All brands appear in the type, so the cast succeeds */\n    return left(v);\n}\nfunction enhanced_cast(brands,v) {\n    var type = v.$class;\n    if (brands.length != 1)\n throw \"Can't handle multiple brands yet\";\n    var brand = brands[0];\n    if (brand == type || brand == \"Any\" || sub_brand(type, brand)) {\n     return left(v);\n    }\n    return right(null);\n}\nfunction singleton(v) {\n    if (v.length == 1) {\n return left(v[0]);\n    } else {\n return right(null); /* Not a singleton */\n    }\n}\nfunction unbrand(v) {\n    if (typeof v === \"object\")\n if (\"$class\" in v) {\n     return remove(v,\"$class\");\n } else {\n     return (\"$data\" in v) ? v.$data : v;\n }\n    throw \"TypeError: unbrand called on non-object\";\n}\nfunction brand(b,v) {\n    return { \"$type\" : b, \"$data\" : v };\n}\nfunction either(v) {\n    if (v == null)\n return false;\n    if (typeof v === \"object\")\n return !(\"$right\" in v);\n    return true;\n}\nfunction toLeft(v) {\n    if (typeof v === \"object\") {\n if (\"$left\" in v)\n     return v.$left;\n if (\"$value\" in v)\n     return v.$value;\n if (looksLikeRelationship(v))\n     return v[\"key\"];\n    }\n    return v;\n}\nfunction toRight(v) {\n    if (v === null)\n return null;\n    if (typeof v === \"object\" && \"$right\" in v)\n return v.$right;\n    return undefined;\n}\nfunction deref(receiver, member) {\n    if (typeof receiver === \"object\" && member in receiver) {\n var ans = receiver[member];\n if (ans === null) {\n     return null;\n }\n if (typeof ans === \"object\" && looksLikeRelationship(ans))\n     ans = left(ans[\"key\"]);\n if ((\"$class\" in receiver) && typeof ans === \"object\" && !(\"$left\" in ans) && !Array.isArray(ans))\n     ans = left(ans);\n return ans;\n    }\n    return undefined;\n}\nfunction looksLikeRelationship(v) {\n    // As the name suggests, this is only heuristic.  We call it a relationship if it has two or three members.\n    // A \"key\" and \"$type\" member must be among those.   A third member, if present, must be $class and must denote\n    // the relationship class.\n    var hasKey = false;\n    var hasType = false;\n    for (var member in v)\n if (member == \"key\")\n     hasKey = true;\n    else if (member == \"$type\")\n hasType = true;\n    else if (member == \"$class\" && v[\"$class\"] == \"com.ibm.ia.model.Relationship\")\n continue;\n    else\n return false;\n    return hasKey && hasType;\n}\nfunction mkWorld(v) {\n    return { \"WORLD\" : v };\n}\n\n// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions\nfunction escapeRegExp(string){\n    return string.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n}\n\n// Nat operations\n\nfunction natPlus(v1, v2) {\n    return { \"$nat\" : v1.$nat + v2.$nat };\n}\nfunction natMinus(v1, v2) {\n    return { \"$nat\" : v1.$nat - v2.$nat };\n}\nfunction natMult(v1, v2) {\n    return { \"$nat\" : v1.$nat * v2.$nat };\n}\nfunction natDiv(v1, v2) {\n    return { \"$nat\" : Math.floor(v1.$nat / v2.$nat) };\n}\nfunction natDiv(v1, v2) {\n    return { \"$nat\" : Math.floor(v1.$nat / v2.$nat) };\n}\nfunction natRem(v1, v2) {\n    return { \"$nat\" : Math.floor(v1.$nat % v2.$nat) };\n}\nfunction natMin(v1, v2) {\n    return { \"$nat\" : Math.min(v1.$nat,v2.$nat) };\n}\nfunction natMax(v1, v2) {\n    return { \"$nat\" : Math.max(v1.$nat,v2.$nat) };\n}\nfunction natAbs(v) {\n    return { \"$nat\" : Math.abs(v.$nat) };\n}\nfunction natLog2(v) {\n    return { \"$nat\" : Math.floor(Math.log2(v.$nat)) }; // Default Z.log2 is log_inf, biggest integer lower than log2\n}\nfunction natSqrt(v) {\n    return { \"$nat\" : Math.floor(Math.sqrt(v.$nat)) }; // See Z.sqrt biggest integer lower than sqrt\n}\nfunction natSum(b) {\n    var result = 0;\n    for (var i=0; i<b.length; i++)\n result += b[i].$nat;\n    return { \"$nat\" : result };\n}\nfunction natMinApply(b) {\n    var numbers = [ ];\n    for (var i=0; i<b.length; i++)\n numbers.push(b[i].$nat);\n    return { \"$nat\" : Math.min.apply(Math,numbers) };\n}\nfunction natMaxApply(b) {\n    var numbers = [ ];\n    for (var i=0; i<b.length; i++)\n numbers.push(b[i].$nat);\n    return { \"$nat\" : Math.max.apply(Math,numbers) };\n}\nfunction natArithMean(b) {\n    var len = b.length;\n    if(len == 0) {\n return { \"$nat\" : 0 };\n    } else {\n return { \"$nat\" : Math.floor(natSum(b)/len) };\n    }\n}\nfunction count(v) {\n    return { \"$nat\" : v.length };\n}\nfunction stringLength(v) {\n    return { \"$nat\" : v.length };\n}\nfunction floatOfNat(v) {\n    return v.$nat;\n}\nfunction substring(v, start, len) {\n    return v.substring(start,len);\n}\nfunction substringNoLength(v, start) {\n    return v.substring(start);\n}\nfunction stringJoin(sep, v) {\n    return v.join(sep);\n}\n/*\n * Copyright 2016 Joshua Auerbach\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* Addendum to \"standard library\" with limited support for SQL-style dates and durations (aka \"intervals\") */\n\nvar DAY = \"DAY\";\nvar MONTH = \"MONTH\";\nvar YEAR = \"YEAR\";\n\nfunction sqlGetDateComponent(part, date) {\n    mustBeDate(date);\n    switch(part) {\n    case DAY:\n return date.day;\n    case MONTH:\n return date.month;\n    case YEAR:\n return date.year;\n    default:\n throw new Error(\"Uninterpretable part: \" + part);\n    }\n}\n\nfunction sqlDateFromString(stringDate) {\n    if (typeof stringDate === \"string\") {\n parts = stringDate.split(\"-\");\n if (parts.length === 3)\n     return makeDate(Number(parts[0]), Number(parts[1]), Number(parts[2]));\n throw new Error(\"Malformed string date: \" + stringDate);\n    }\n    throw new Error(\"Expected a date in string form but got \" + JSON.stringify(stringDate));\n}\n\nfunction sqlDateDurationFromString(stringDuration) {\n    // TODO verify what the string format for durations is going to be.\n    // Here we assume a number adjoined to a valid unit with a dash.\n    if (typeof stringDuration === \"string\") {\n parts = stringDuration.split(\"-\");\n if (parts.length === 2) {\n     mustBeUnit(parts[1]);\n     return {\"duration\": Number(parts[0]), \"unit\": parts[1]};\n     throw new Error(\"Malformed string duration: \" + stringDuration);\n }\n throw new Error(\"Expected a duration in string form but got \" + JSON.stringify(stringDuration));\n    }\n}\n\nfunction sqlDatePointPlus(date, duration) {\n    mustBeDate(date);\n    mustBeDuration(duration);\n    switch(duration.unit) {\n    case DAY:\n return dateNewDay(date, date.day + duration.duration);\n    case MONTH:\n return dateNewMonth(date, date.month + duration.duration);\n    case YEAR:\n return dateNewYear(date, date.year + duration.duration);\n    default:\n throw new Error(\"Unexpected state (not supposed to happen)\");\n    }\n}\n\nfunction sqlDatePointMinus(date, duration) {\n    mustBeDate(date);\n    mustBeDuration(duration);\n    switch(duration.unit) {\n    case DAY:\n return dateNewDay(date, date.day - duration.duration);\n    case MONTH:\n return dateNewMonth(date, date.month - duration.duration);\n    case YEAR:\n return dateNewYear(date, date.year - duration.duration);\n    default:\n throw new Error(\"Unexpected bad unit (not supposed to happen)\");\n    }\n}\n\nfunction sqlDatePointNe(date1, date2) {\n    mustBeDate(date1);\n    mustBeDate(date2);\n    return compareDates(date1, date2) != 0;\n}\n\nfunction sqlDatePointLt(date1, date2) {\n    mustBeDate(date1);\n    mustBeDate(date2);\n    return compareDates(date1, date2) < 0;\n}\n\nfunction sqlDatePointLe(date1, date2) {\n    mustBeDate(date1);\n    mustBeDate(date2);\n    return compareDates(date1, date2) <= 0;\n}\n\nfunction sqlDatePointGt(date1, date2) {\n    mustBeDate(date1);\n    mustBeDate(date2);\n    return compareDates(date1, date2) > 0;\n}\n\nfunction sqlDatePointGe(date1, date2) {\n    mustBeDate(date1);\n    mustBeDate(date2);\n    return compareDates(date1, date2) >= 0;\n}\n\nfunction sqlDateDurationBetween(date1, date) {\n    throw new Error(\"We don't know how to do 'duration between' dates yet\");\n}\n\nfunction compareDates(date1, date2) {\n    // java.lang.System.out.println(\"Comparing \" + JSON.stringify(date1) + \" and \" + JSON.stringify(date2) + \" = \");\n    if (date1.year < date2.year)\n return -1;\n    if (date1.year > date2.year)\n return 1;\n    if (date1.month < date2.month)\n return -1;\n    if (date1.month > date2.month)\n return 1;\n    if (date1.day < date2.day)\n return -1;\n    if (date1.day > date2.day)\n return 1;\n    return 0;\n}\n\nfunction dateNewYear(date, year) {\n    return makeDate(year, date.month, date.day);\n}\n\nfunction dateNewMonth(date, month) {\n    /* Use Javascript Date object to normalize out-of-range month */\n    var jsDate = new Date(date.year, month-1, date.day);\n    return makeDate(jsDate.getFullYear(), jsDate.getMonth()+1, jsDate.getDate());\n}\n\nfunction dateNewDay(date, day) {\n    /* Use Javascript Date object to normalize out-of-range day */\n    var jsDate = new Date(date.year, date.month-1, day);\n    return makeDate(jsDate.getFullYear(), jsDate.getMonth()+1, jsDate.getDate());\n}\n\nfunction makeDate(year, month, day) {\n    return {\"year\": year, \"month\": month, \"day\": day};\n}\n\nfunction mustBeDate(date) {\n    if (typeof date === \"object\" && \"year\" in date && \"month\" in date && \"day\" in date)\n return;\n    throw new Error(\"Expected a date but got \" + JSON.stringify(date));\n}\n\nfunction mustBeDuration(duration) {\n    if (typeof duration === \"object\" && \"duration\" in duration && \"unit\" in duration) {\n mustBeUnit(duration.unit);\n return;\n    }\n    throw new Error(\"Expected a duration but got \" + JSON.stringify(duration));\n}\n\nfunction mustBeUnit(unit) {\n    if (unit === DAY || unit === MONTH || unit === YEAR)\n return;\n    throw new Error(\"Expected a duration unit but got \" + JSON.stringify(unit));\n}\n"
